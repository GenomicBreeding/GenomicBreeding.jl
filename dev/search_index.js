var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GenomicBreeding","category":"page"},{"location":"#GenomicBreeding","page":"Home","title":"GenomicBreeding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GenomicBreeding.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GenomicBreeding]","category":"page"},{"location":"#GenomicBreeding.Genomes","page":"Home","title":"GenomicBreeding.Genomes","text":"Genomes struct\n\nContaines unique entries and loci_alleles where allele frequencies can have missing values\n\nConstructor\n\nGenomes(; n::Int = 1, p::Int = 2)\n\nFields\n\nentries: names of the n entries or samples\npopulations: name/s of the population/s each entries or samples belong to\nloci_alleles: names of the p loci-alleles combinations (p = l loci x a-1 alleles) including the chromsome or scaffold name, position, all alleles, and current allele separated by tabs\nallele_frequencies: n x p matrix of allele frequencies between 0 and 1 which can have missing values\nmask: n x p matrix of boolean mask for selective analyses and slicing\n\nExamples\n\njulia> genomes = Genomes(n=2, p=2)\nGenomes([#undef, #undef], [#undef, #undef], [#undef, #undef], Union{Missing, Real}[#undef #undef; #undef #undef], Bool[0 0; 0 0])\n\njulia> fieldnames(Genomes)\n(:entries, :populations, :loci_alleles, :allele_frequencies, :mask)\n\njulia> genomes.entries = [\"entry_1\", \"entry_2\"];\n\njulia> genomes.populations = [\"pop_1\", \"pop_1\"];\n\njulia> genomes.loci_alleles = [\"chr1_12345_A|T_A\", \"chr2_678910_C|D_D\"];\n\njulia> genomes.allele_frequencies = [0.5 0.25; 0.9 missing];\n\njulia> genomes.mask = [true true; true false];\n\njulia> genomes\nGenomes([\"entry_1\", \"entry_2\"], [\"pop_1\", \"pop_1\"], [\"chr1_12345_A|T_A\", \"chr2_678910_C|D_D\"], Union{Missing, Real}[0.5 0.25; 0.9 missing], Bool[1 1; 1 0])\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreeding.Phenomes","page":"Home","title":"GenomicBreeding.Phenomes","text":"Phenomes struct\n\nConstains unique entries and traits where phenotype data can have missing values\n\nConstructor\n\nPhenomes(; n::Int = 1, t::Int = 2)\n\nFields\n\nentries: names of the n entries or samples\npopulations: name/s of the population/s each entries or samples belong to\ntraits: names of the t traits\nphenotypes: n x t matrix of numeric (R) phenotype data which can have missing values\nmask: n x t matrix of boolean mask for selective analyses and slicing\n\nExamples\n\njulia> phenomes = Phenomes(n=2, t=2)\nPhenomes([#undef, #undef], [#undef, #undef], [#undef, #undef], Union{Missing, Real}[#undef #undef; #undef #undef], Bool[0 0; 0 0])\n\njulia> fieldnames(Phenomes)\n(:entries, :populations, :traits, :phenotypes, :mask)\n\njulia> phenomes.entries = [\"entry_1\", \"entry_2\"];\n\njulia> phenomes.populations = [\"pop_A\", \"pop_B\"];\n\njulia> phenomes.traits = [\"height\", \"yield\"];\n\njulia> phenomes.phenotypes = [200.0 2.5; 150.0 missing];\n\njulia> phenomes.mask = [true true; true false];\n\njulia> phenomes\nPhenomes([\"entry_1\", \"entry_2\"], [\"pop_A\", \"pop_B\"], [\"height\", \"yield\"], Union{Missing, Real}[200.0 2.5; 150.0 missing], Bool[1 1; 1 0])\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreeding.Trials","page":"Home","title":"GenomicBreeding.Trials","text":"Trials struct\n\nContains phenotype data across years, seasons, harvest, sites, populations, replications, blocks, rows, and columns\n\nConstructor\n\nTrials(; n::Int = 2, p::Int = 2)\n\nFields\n\nphenotypes: n x t matrix of numeric phenotype data which can have missing values\ntraits: names of the traits t traits\nyears: names of the years corresponding to each row in the phenotype matrix\nseasons: names of the seasons corresponding to each row in the phenotype matrix\nharvests: names of the harvests corresponding to each row in the phenotype matrix\nsites: names of the sites corresponding to each row in the phenotype matrix\nreplications: names of the replications corresponding to each row in the phenotype matrix\nblocks: names of the blocks corresponding to each row in the phenotype matrix\nrows: names of the rows corresponding to each row in the phenotype matrix\ncols: names of the cols corresponding to each row in the phenotype matrix\nentries: names of the entries corresponding to each row in the phenotype matrix\npopulations: names of the populations corresponding to each row in the phenotype matrix\n\nExamples\n\njulia> trials = Trials(n=1, t=2)\nTrials(Union{Missing, Real}[#undef #undef], [#undef, #undef], [#undef], [#undef], [#undef], [#undef], [#undef], [#undef], [#undef], [#undef], [#undef], [#undef])\n\njulia> fieldnames(Trials)\n(:phenotypes, :traits, :years, :seasons, :harvests, :sites, :replications, :blocks, :rows, :cols, :entries, :populations)\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreeding.checkdims-Tuple{Genomes}","page":"Home","title":"GenomicBreeding.checkdims","text":"checkdims(genomes::Genomes)::Bool\n\nCheck dimension compatibility of the fields of the Genomes struct\n\nExamples\n\njulia> genomes = Genomes(n=2,p=4);\n\njulia> checkdims(genomes)\ntrue\n\njulia> genomes.entries = [\"beaking_change\"];\n\njulia> checkdims(genomes)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.checkdims-Tuple{Phenomes}","page":"Home","title":"GenomicBreeding.checkdims","text":"checkdims(y::Phenomes)::Bool\n\nCheck dimension compatibility of the fields of the Phenomes struct\n\nExamples\n\njulia> y = Phenomes(n=2, t=2);\n\njulia> checkdims(y)\ntrue\n\njulia> y.populations = [\"beaking_change\"];\n\njulia> checkdims(y)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.checkdims-Tuple{Trials}","page":"Home","title":"GenomicBreeding.checkdims","text":"checkdims(trials::Trials)::Bool\n\nCheck dimension compatibility of the fields of the Trials struct\n\nExamples\n\njulia> trials = Trials(n=1, t=2);\n\njulia> trials.entries = [\"entry_1\"];\n\njulia> checkdims(trials)\ntrue\n\njulia> trials.entries = [\"entering_2_entries\", \"instead_of_just_1\"];\n\njulia> checkdims(trials)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.dimensions-Tuple{Genomes}","page":"Home","title":"GenomicBreeding.dimensions","text":"dimensions(genomes::Genomes)::Tuple{Int, Int, Int}\n\nCount the number of entries, populations, loci, and maximum number of alleles per locus in the Genomes struct\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> dimensions(genomes)\n(100, 100, 3000, 1000, 4)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.simulateeffects-Tuple{}","page":"Home","title":"GenomicBreeding.simulateeffects","text":"Simulate effects\n\nSample p x q effects from a multivariate normal distribution with μ~Exp(λ) and Σ=μμ'\n\nArguments\n\np: number of correlated effects to simulate (default = 2)\nq: number times to simulate the correlated effects from the same distribution (default = 1)\nλ: parameter of the exponential distritbution from which the means will be sampled from (default = 1.00)\nseed: randomisation seed (default = 42)\n\nOutput\n\np x q matrix of correlated effects\n\nExamples\n\njulia> θ::Array{Real,2} = simulateeffects();\n\njulia> sum(abs.(θ - [-0.0886501800782904; -0.596478483888422])) < 0.00001\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.simulategenomes-Tuple{}","page":"Home","title":"GenomicBreeding.simulategenomes","text":"Simulate genomes\n\nArguments\n\nn: number of entries (default = 100)\nl: number of loci (default = 10_000)\nn_chroms: number of chromosomes (default = 7)\nn_alleles: number of alleles per locus (default = 2)\nmax_pos: total length of the genome in base-pairs (bp) (default = 135000000)\nld_corr_50perc_kb: distance in bp at which linkage expressed as correlation between a pair of loci is at 50% (default = 100_000)\nseed: psuedo-random number generator seed for replicability (default = 42)\nverbose: Show progress bar and plot the linkage heatmap into an svg file? (default = true)\n\nOutput\n\nGenomes\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=10_000, n_alleles=3, verbose=false);\n\njulia> length(genomes.entries)\n100\n\njulia> length(genomes.populations)\n100\n\njulia> length(genomes.loci_alleles)\n20000\n\njulia> size(genomes.allele_frequencies)\n(100, 20000)\n\njulia> rng::TaskLocalRNG = Random.seed!(123);\n\njulia> idx = StatsBase.sample(rng, range(1, 20_000, step=2), 250, replace = false, ordered = true);\n\njulia> correlations = StatsBase.cor(genomes.allele_frequencies[:, idx]);\n\njulia> correlations[10,10] == 1.00\ntrue\n\njulia> correlations[10,10] > correlations[10,250]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.simulategenomiceffects-Tuple{}","page":"Home","title":"GenomicBreeding.simulategenomiceffects","text":"Simulate genomic effects\n\nSimulate additive, dominance, and epistatic effects\n\nArguments\n\ngenomes: Genome struct includes the n entries x p loci-alleles combinations (p = l loci x a-1 alleles)\nf_additive: proportion of the l loci with non-zero additive effects on the phenotype\nf_dominance: proportion of the l*f_additive additive effects loci with additional dominance effects\nf_epistasis: proportion of the l*f_additive additive effects loci with additional epistasis effects\n\nOutputs\n\nn x 3 matrix of additive, dominance and epistasis effects per entry\np x 3 matrix of additive, dominance and epistasis effects per locus-allele combination\n\nExamples\n\njulia> genomes::Genomes = simulategenomes(n=100, l=2_000, n_alleles=3, verbose=false);\n\njulia> G, B = simulategenomiceffects(genomes=genomes, f_additive=0.05, f_dominance=0.75, f_epistasis=0.25);\n\njulia> size.([G, B])\n2-element Vector{Tuple{Int64, Int64}}:\n (100, 3)\n (4000, 3)\n\njulia> sum(B .!= 0.0, dims=1)\n1×3 Matrix{Int64}:\n 200  75  50\n\nDetails\n\nThe additive, dominance, and epistasis allele effects share a common exponential distribution (λ=1) from which  the mean of the effects (μ) are sampled, and the covariance matrix is derived (Σ = μ * μ';  where if det(Σ)≈0 then we iteratively add 1.00 to the diagonals until it becomes invertible or 10 iterations  finishes and throws an error). The non-additive or epistasis allele effects were simulated by multiplying the allele  frequencies of all possible unique pairs of epistasis alleles and their effects.\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.simulatetrials-Tuple{}","page":"Home","title":"GenomicBreeding.simulatetrials","text":"Simulate trials\n\nArguments\n\ngenomes: Genome struct includes the n entries x p loci-alleles combinations (p = l loci x a-1 alleles)\nn_traits: Number of traits (default = 3)\nn_years: Number of years (default = 2)\nn_seasons: Number of seasons (default = 4)\nn_harvests: Number of harvests (default = 2)\nn_sites: Number of sites (default = 4)\nn_replications: Number of replications (default = 2)\nn_blocks: Number of blocks across the entire field layout (default = missing)\nn_rows: Number of rows across the entire field layout (default = missing)\nn_cols: Number of columns across the entire field layout (default = missing)\nproportion_of_variance: 12 x n_traits numeric matrix of scaled/non-scaled proportion of variances allocated to   genetic and environmental effects (default = missing; values will be sampled from a uniform distribution  followed by a biased sample on the first row, i.e. additive effects row).  The rows correspond to the variance allocated to:\nadditive genetic effects\ndominance genetic effects\nepistasis genetic effects\nyears effects\nseasons effects\nharvests effects\nsites effects\nreplications effects\nblocks effects\nrows effects\ncols effects\ncomplex interaction effects\nseed: Randomisation seed (default = 42)\nsparsity: Proportion of missing data (default = 0.0)\nverbose: Show trials simulation progress bar? (default = true)\n\nOutput\n\nTrials\n\nExamples\n\njulia> genomes::Genomes = simulategenomes(n=100, l=2_000, n_alleles=3, verbose=false);\n\njulia> trials::Trials = simulatetrials(genomes=genomes, sparsity=0.25, verbose=false);\n\njulia> size(trials.phenotypes)\n(12800, 3)\n\njulia> size(trials.traits)\n(3,)\n\njulia> unique(trials.entries) == genomes.entries\ntrue\n\njulia> unique(trials.populations) == unique(genomes.populations)\ntrue\n\njulia> abs(mean(ismissing.(trials.phenotypes)) - 0.25) < 0.00001\ntrue\n\n\n\n\n\n","category":"method"}]
}
