var documenterSearchIndex = {"docs":
[{"location":"models/","page":"Models","title":"Models","text":"CurrentModule = GenomicBreeding","category":"page"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Models","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"","category":"page"},{"location":"models/#Linear-mixed-models-for-analysing-trial","page":"Models","title":"Linear mixed models for analysing trial","text":"","category":"section"},{"location":"models/#Linear-models-for-genomic-prediction","page":"Models","title":"Linear models for genomic prediction","text":"","category":"section"},{"location":"models/#Non-linear-models-for-genomic-prediction","page":"Models","title":"Non-linear models for genomic prediction","text":"","category":"section"},{"location":"models/#Epifeat","page":"Models","title":"Epifeat","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GenomicBreeding","category":"page"},{"location":"#GenomicBreeding","page":"Home","title":"GenomicBreeding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GenomicBreeding.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GenomicBreeding]","category":"page"},{"location":"#GenomicBreeding.GBInput","page":"Home","title":"GenomicBreeding.GBInput","text":"mutable struct GBInput\n\nMain input struct for genomic breeding analysis (implements GBCore.AbstractGB)\n\nFields\n\nRequired\n\nfname_geno: Path to genotype file (see file format guide for details)\n\nOptional Data Files\n\nfname_pheno: Path to phenotype file (Default: \"\" - see file format guide for details)\nfname_allele_effects_jld2s: Vector of paths to JLD2 files containing Fit structs (Default: [\"\"])\n\nAnalysis Settings\n\nanalysis: Analysis function to perform (Default: cv)\ncv: Replicated k-fold cross-validation\nfit: Fit genomic prediction models to extract allele effects\npredict: Compute GEBVs using existing model fits\ngwas: Genome-wide association study\nbulk_cv: Perform cross-validation across all populations (Default: false)\npopulations: Vector of populations to include (Default: all)\ntraits: Vector of traits to analyze (Default: all)\nmodels: Vector of genomic prediction model functions (Default: [ridge, bayesa])\ngwas_models: Vector of GWAS model functions (Default: [gwasols, gwaslmm])\n\nCross-Validation Parameters\n\nn_folds: Number of CV folds (Default: 5)\nn_replications: Number of CV replications (Default: 5)\n\nFiltering Parameters\n\nkeep_all: Keep all entries when merging data (Default: false)\nmaf: Minimum allele frequency (Default: 0.05)\nmtv: Minimum trait variance (Default: 1e-7)\n\nModel Parameters\n\nn_iter: MCMC iterations (Default: 1_500)\nn_burnin: MCMC burn-in iterations (Default: 500)\n\nOutput Settings\n\nfname_out_prefix: Output file prefix & directory (Default: GBOutput/output-<timestamp>-)\nverbose: Show progress messages (Default: true)\n\nSLURM Settings\n\nSLURM_job_name: Job array name (Default: GBJob-<timestamp>)\nSLURM_account_name: Account name (Default: \"\")\nSLURM_partition_name: Partition to use (Default: \"\")\nSLURM_nodes_per_array_job: Nodes per job (Default: 1)\nSLURM_tasks_per_node: Tasks per node (Default: 1)\nSLURM_cpus_per_task: CPUs per task (Default: 1)\nSLURM_mem_G: Memory in GB (Default: 1)\nSLURM_time_limit_dd_hhmmss: Time limit as \"dd-hh:mm:ss\" (Default: \"00-01:00:00\")\nSLURM_max_array_jobs_running: Max concurrent array jobs (Default: 20)\nSLURM_module_load_Conda_version_name: Conda module name (Default: \"Miniconda3\")\nSLURM_module_load_R_version_name: R module name (Default: \"conda\" which will use the R installed in the conda environment - see installation instructions for details)\nSLURM_module_load_Julia_version_name: Julia module name (Default: \"\" which will use the Julia installed via JuliaUp - see installation instructions for details)\n\n\n\n\n\n","category":"type"},{"location":"#Base.:==-Tuple{GBInput, GBInput}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::GBInput, y::GBInput)::Bool\n\nCompare two GBInput structs for equality by comparing their hash values.\n\nThis method overloads the == operator for GBInput structs, allowing direct comparison using the == operator. Two GBInput structs are considered equal if they have identical hash values, which implies they have the same values for all relevant fields.\n\nArguments\n\nx::GBInput: First GBInput struct to compare\ny::GBInput: Second GBInput struct to compare\n\nReturns\n\nBool: true if the hash values of both structs are equal, false otherwise\n\nExamples\n\njulia> input_1 = input = GBInput(fname_geno=\"geno1.jld2\", fname_pheno=\"pheno1.jld2\", fname_out_prefix=\"test1-\", SLURM_job_name=\"slurmjob1\");\n\njulia> input_2 = input = GBInput(fname_geno=\"geno1.jld2\", fname_pheno=\"pheno1.jld2\", fname_out_prefix=\"test1-\", SLURM_job_name=\"slurmjob1\");\n\njulia> input_3 = input = GBInput(fname_geno=\"geno2.jld2\", fname_pheno=\"pheno2.jld2\");\n\njulia> input_1 == input_2\ntrue\n\njulia> input_1 == input_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{GBInput, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::GBInput, h::UInt)::UInt\n\nCompute a hash value for a GBInput struct by combining the hash values of all its fields.\n\nArguments\n\nx::GBInput: The input structure to be hashed\nh::UInt: The hash value seed\n\nReturns\n\nUInt: A hash value that uniquely identifies the content of the GBInput struct\n\nDetails\n\nThis method implements hash computation for the GBInput type by iterating through all fields and combining their hash values.\n\nExamples\n\njulia> input = GBInput(fname_geno=\"\", fname_pheno=\"\");\n\njulia> typeof(hash(input))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{GBInput}","page":"Home","title":"GBCore.checkdims","text":"checkdims(input::GBInput)::Bool\n\nCheck dimension compatibility of the fields of the GBInput struct. Returns true if both models and gwas_models fields in the input are not nothing, false otherwise.\n\nArguments\n\ninput::GBInput: Input structure containing genomic data and models\n\nReturns\n\nBool: true if dimensions are compatible, false otherwise\n\nExamples\n\njulia> input = GBInput(fname_geno=\"geno1.jld2\", fname_pheno=\"pheno1.jld2\");\n\njulia> checkdims(input)\ntrue\n\njulia> input.models = nothing\n\njulia> checkdims(input)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.clone-Tuple{GBInput}","page":"Home","title":"GBCore.clone","text":"clone(x::GBInput)::GBInput\n\nCreate a deep copy of a GBInput object, duplicating all field values into a new instance.\n\nThis function allows you to create an independent copy of a GBInput object where modifications  to the clone won't affect the original object.\n\nArguments\n\nx::GBInput: The source GBInput object to be cloned\n\nReturns\n\n::GBInput: A new GBInput instance with identical field values\n\nExample\n\njulia> input = GBInput(fname_geno=\"geno1.jld2\", fname_pheno=\"pheno1.jld2\");\n\njulia> copy_input = clone(input);\n\njulia> input == copy_input\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.checkinputs-Tuple{GBInput}","page":"Home","title":"GenomicBreeding.checkinputs","text":"checkinputs(input::GBInput)::Vector{String}\n\nCheck the compatibility and validity of inputs for genomic analysis.\n\nReturns a vector of error messages. An empty vector indicates all inputs are valid.\n\nArguments\n\ninput::GBInput: A struct containing analysis parameters including:\nanalysis: Analysis type (cv, fit, predict, or gwas)\nfname_geno: Path to genotype file\nfname_pheno: Path to phenotype file\nmodels: Vector of selected models\nfname_allele_effects_jld2s: Paths to allele effects files (for predict)\n\nReturns\n\nVector{String}: Collection of error messages, empty if all inputs are valid\n\nValidation Rules\n\nAnalysis type must be one of: cv, fit, predict, or gwas\nFor cv, fit, and gwas:\nGenotype file must exist\nPhenotype file must exist\nAt least one model must be specified\nFor predict:\nGenotype file must exist\nAll specified allele effects files must exist\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fname_geno = try writedelimited(genomes, fname=\"test-geno.tsv\"); catch; rm(\"test-geno.tsv\"); writedelimited(genomes, fname=\"test-geno.tsv\"); end;\n    \njulia> fname_pheno = try writedelimited(phenomes, fname=\"test-pheno.tsv\"); catch; rm(\"test-pheno.tsv\"); writedelimited(phenomes, fname=\"test-pheno.tsv\"); end;\n\njulia> input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=cv);\n\njulia> length(checkinputs(input)) == 0\ntrue\n\njulia> input.fname_pheno = \"\"; length(checkinputs(input)) == 0\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.cv-Tuple{GBInput}","page":"Home","title":"GenomicBreeding.cv","text":"cv(input::GBInput)::Tuple{Vector{String},Vector{String}}\n\nAssess genomic prediction accuracy via replicated k-fold cross-validation.\n\nArguments\n\ninput::GBInput: A GBInput struct containing configuration parameters including:\nbulk_cv: Boolean flag for bulk cross-validation\npopulations: Vector of population names to analyze\nmodels: Statistical models to use for prediction\nn_folds: Number of folds for cross-validation\nn_replications: Number of replications for cross-validation\nfname_out_prefix: Prefix for output filenames\nverbose: Boolean flag for detailed output\n\nReturns\n\nTuple{Vector{String},Vector{String}}: A tuple containing:\nFirst element: Vector of paths to JLD2 files containing CV results\nSecond element: Vector of paths to text files containing error notes\n\nDetails\n\nThe function supports three types of cross-validation:\n\nSingle population CV when one population is specified\nPairwise population CV when two populations are specified\nBoth pairwise and leave-one-population-out CV when more than two populations are specified\n\nResults are saved as JLD2 files (one per fold, replication, and trait) and optional text files  containing notes about failed jobs.\n\nExample\n\njulia> genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> proportion_of_variance = fill(0.0, 9, 3); proportion_of_variance[1, :] .= 1.00; # 100% variance on the additive genetic effects\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, proportion_of_variance=proportion_of_variance, verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fname_geno = try writedelimited(genomes, fname=\"test-geno.tsv\"); catch; rm(\"test-geno.tsv\"); writedelimited(genomes, fname=\"test-geno.tsv\"); end;\n\njulia> fname_pheno = try writedelimited(phenomes, fname=\"test-pheno.tsv\"); catch; rm(\"test-pheno.tsv\"); writedelimited(phenomes, fname=\"test-pheno.tsv\"); end;\n\njulia> input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=cv, bulk_cv=false, fname_out_prefix=\"GBOutput_cv_3/output-3-\", populations=[\"pop_1\", \"pop_3\"], traits=[\"trait_1\"], n_replications=2, n_folds=3, verbose=false);\n\njulia> fnames_cvs, fnames_notes = cv(input);\n\njulia> length(fnames_cvs) == 4, length(fnames_notes) == 0\n(true, true)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.fit-Tuple{GBInput}","page":"Home","title":"GenomicBreeding.fit","text":"fit(input::GBInput)::Vector{String}\n\nExtract allele effects by fitting genomic prediction models without cross-validation.\n\nArguments\n\ninput::GBInput: A GBInput struct containing:\nfname_geno: Path to genotype data file\nfname_pheno: Path to phenotype data file\nmodels: Vector of model functions to fit (e.g., [bayesa, bayesb])\ntraits: Optional vector of trait names to analyze\npopulations: Optional vector of population names to analyze\nn_iter: Number of iterations for Bayesian models\nn_burnin: Number of burn-in iterations for Bayesian models\nverbose: Boolean for detailed output\n\nReturns\n\nVector{String}: Paths to JLD2 files containing fitted model results, one file per model-trait-population combination\n\nDetails\n\nThe function fits specified genomic prediction models to the full dataset without cross-validation.  For each combination of model, trait, and population, it:\n\nLoads and processes genotype and phenotype data\nFits the specified model\nSaves results to a JLD2 file with naming pattern: {prefix}_model_{name}-trait_{name}-population_{name}.jld2\n\nNotes\n\nIf populations is not specified, all unique populations in phenotype data are used\nIf traits is not specified, all unique traits in phenotype data are used\nFor Bayesian models (names containing \"bayes\"), uses specified iterations and burn-in\nWill throw an error if output files already exist\n\nExample\n\njulia> genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> proportion_of_variance = fill(0.0, 9, 3); proportion_of_variance[1, :] .= 1.00; # 100% variance on the additive genetic effects\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, proportion_of_variance=proportion_of_variance, verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fname_geno = try writedelimited(genomes, fname=\"test-geno.tsv\"); catch; rm(\"test-geno.tsv\"); writedelimited(genomes, fname=\"test-geno.tsv\"); end;\n\njulia> fname_pheno = try writedelimited(phenomes, fname=\"test-pheno.tsv\"); catch; rm(\"test-pheno.tsv\"); writedelimited(phenomes, fname=\"test-pheno.tsv\"); end;\n\njulia> input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=GenomicBreeding.fit, fname_out_prefix=\"GBOutput_fit_4/output-4-\", populations=[\"pop_1\", \"pop_3\"], traits=[\"trait_1\"], models=[bayesa, bayesb], verbose=false);\n\njulia> fname_allele_effects_jld2s = GenomicBreeding.fit(input);\n\njulia> length(fname_allele_effects_jld2s) == 4\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.gwas-Tuple{GBInput}","page":"Home","title":"GenomicBreeding.gwas","text":"gwas(input::GBInput)::Vector{String}\n\nPerform genome-wide association study (GWAS) analysis on genomic and phenotypic data.\n\nArguments\n\ninput::GBInput: A GBInput struct containing:\nfname_geno: Path to genotype data file\nfname_pheno: Path to phenotype data file\ngwas_models: Vector of GWAS models to apply\ntraits: Optional vector of trait names to analyze\npopulations: Optional vector of population names to analyze\nverbose: Boolean flag for detailed output\n\nReturns\n\nVector{String}: Paths to generated JLD2 files containing Fit structs for each model-trait-population combination\n\nDetails\n\nThe function performs GWAS analysis for each combination of:\n\nGWAS models specified in input\nTraits found in phenotype data\nPopulations specified (if none specified, analyzes all data together)\n\nFor each combination, it:\n\nFilters data for the specific population if specified\nFits the GWAS model\nSaves results to a JLD2 file containing a Fit struct\n\nThe Fit struct's b_hat field contains:\n\nt-statistics for gwasols model\nz-statistics for other GWAS models\n\nNotes\n\nOutput files are named as: <prefix>_model_<model>-trait_<trait>-population_<pop>.jld2\nWill throw an error if output files already exist\nWhen verbose=true, displays a progress bar and correlation heatmap of estimated allele effects\n\nExample\n\njulia> genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> proportion_of_variance = fill(0.0, 9, 3); proportion_of_variance[1, :] .= 1.00; # 100% variance on the additive genetic effects\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, proportion_of_variance=proportion_of_variance, verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fname_geno = try writedelimited(genomes, fname=\"test-geno.tsv\"); catch; rm(\"test-geno.tsv\"); writedelimited(genomes, fname=\"test-geno.tsv\"); end;\n\njulia> fname_pheno = try writedelimited(phenomes, fname=\"test-pheno.tsv\"); catch; rm(\"test-pheno.tsv\"); writedelimited(phenomes, fname=\"test-pheno.tsv\"); end;\n\njulia> input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, gwas_models=[gwasols], verbose=false);\n\njulia> fname_test_statistics_jld2s = GenomicBreeding.gwas(input);\n\njulia> length(fname_test_statistics_jld2s) == 3\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.loadcvs-Tuple{GBInput}","page":"Home","title":"GenomicBreeding.loadcvs","text":"loadcvs(input::GBInput; min_train_size::Int64=10)::Vector{CV}\n\nLoad and filter cross-validation (CV) results from files generated by GenomicBreeding.cv().\n\nArguments\n\ninput::GBInput: Input configuration containing the output directory path in fname_out_prefix\nmin_train_size::Int64=10: Minimum required size for training sets (default: 10)\n\nReturns\n\nVector{CV}: Vector of valid CV objects that meet the following criteria:\nContains complete metrics (length of fit.metrics == 9)\nHas valid correlation metric (not missing, NaN, or Inf)\nValidation set size ≥ mintrainsize\n\nThrows\n\nArgumentError: If the output directory doesn't exist or contains no CV results\n\nDetails\n\nThe function searches for files with pattern \"-cv-\" and extension \".jld2\" in the output directory. Invalid or failed CV results are automatically filtered out during loading.\n\nExample\n\njulia> genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> proportion_of_variance = fill(0.0, 9, 3); proportion_of_variance[1, :] .= 1.00; # 100% variance on the additive genetic effects\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, proportion_of_variance=proportion_of_variance, verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fname_geno = try writedelimited(genomes, fname=\"test-geno.tsv\"); catch; rm(\"test-geno.tsv\"); writedelimited(genomes, fname=\"test-geno.tsv\"); end;\n\njulia> fname_pheno = try writedelimited(phenomes, fname=\"test-pheno.tsv\"); catch; rm(\"test-pheno.tsv\"); writedelimited(phenomes, fname=\"test-pheno.tsv\"); end;\n\njulia> input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, fname_out_prefix=\"GBOutput_cv_1/output-1-\", populations=[\"pop_1\", \"pop_3\"], traits=[\"trait_1\"], n_replications=2, n_folds=3, verbose=false);\n\njulia> fnames_cvs, fnames_notes = cv(input);\n\njulia> cvs = loadcvs(input);\n\njulia> length(cvs) == length(fnames_cvs)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.loadfits-Tuple{GBInput}","page":"Home","title":"GenomicBreeding.loadfits","text":"loadfits(input::GBInput)::Vector{Fit}\n\nLoad fitted allele frequency effects from genomic prediction models stored in JLD2 files.\n\nArguments\n\ninput::GBInput: Input configuration containing paths to JLD2 files with fitted allele effects.\n\nReturns\n\nVector{Fit}: Array of Fit objects containing the loaded allele frequency effects.\n\nDetails\n\nThe function attempts to load all JLD2 files specified in input.fname_allele_effects_jld2s. If a file cannot be loaded, that entry will be skipped and remain undef in the output vector.\n\nExample\n\njulia> genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> proportion_of_variance = fill(0.0, 9, 3); proportion_of_variance[1, :] .= 1.00; # 100% variance on the additive genetic effects\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, proportion_of_variance=proportion_of_variance, verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fname_geno = try writedelimited(genomes, fname=\"test-geno.tsv\"); catch; rm(\"test-geno.tsv\"); writedelimited(genomes, fname=\"test-geno.tsv\"); end;\n\njulia> fname_pheno = try writedelimited(phenomes, fname=\"test-pheno.tsv\"); catch; rm(\"test-pheno.tsv\"); writedelimited(phenomes, fname=\"test-pheno.tsv\"); end;\n\njulia> input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, fname_out_prefix=\"GBOutput_fit_2/output-2-\", populations=[\"pop_1\", \"pop_3\"], traits=[\"trait_1\"], models=[bayesa, bayesb], verbose=false);\n\njulia> input.fname_allele_effects_jld2s = GenomicBreeding.fit(input);\n\njulia> fits = loadfits(input);\n\njulia> length(fits) == length(input.fname_allele_effects_jld2s)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.loadgenomesphenomes-Tuple{GBInput}","page":"Home","title":"GenomicBreeding.loadgenomesphenomes","text":"loadgenomesphenomes(input::GBInput)::Tuple{Genomes, Phenomes, Vector{String}, Vector{String}}\n\nLoad, merge, and filter genotype and phenotype data from specified input files.\n\nArguments\n\ninput::GBInput: A struct containing input parameters including:\nfname_geno: Path to genotype data file\nfname_pheno: Path to phenotype data file\nbulk_cv: Boolean for bulk cross-validation\npopulations: Vector of population names to include (optional)\ntraits: Vector of trait names to include (optional)\nn_folds: Number of cross-validation folds\nkeep_all: Boolean to keep all entries during merging\nmaf: Minimum allele frequency threshold\nmtv: Minimum trait variance threshold\nverbose: Boolean for detailed output\n\nReturns\n\nA tuple containing:\n\nGenomes: Filtered genomic data\nPhenomes: Filtered phenotypic data\nVector{String}: Traits to skip due to insufficient data for cross-validation\nVector{String}: Populations to skip due to insufficient data for cross-validation\n\nNotes\n\nSupports multiple file formats (string-delimited, JLD2, VCF)\nPerforms data validation and compatibility checks\nFilters traits with variance below minimum trait variance (mtv) threshold\nEnsures sufficient sample size for cross-validation\nFilters markers based on minimum allele frequency (maf)\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fname_geno = try writedelimited(genomes, fname=\"test-geno.tsv\"); catch; rm(\"test-geno.tsv\"); writedelimited(genomes, fname=\"test-geno.tsv\"); end;\n    \njulia> fname_pheno = try writedelimited(phenomes, fname=\"test-pheno.tsv\"); catch; rm(\"test-pheno.tsv\"); writedelimited(phenomes, fname=\"test-pheno.tsv\"); end;\n\njulia> input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, populations=[\"pop_1\", \"pop_3\"], traits=[\"trait_1\"], verbose=false);\n\njulia> genomes, phenomes, traits_to_skip, populations_to_skip = loadgenomesphenomes(input);\n\njulia> length(unique(genomes.populations)) == length(unique(phenomes.populations)) == 2\ntrue\n\njulia> length(phenomes.traits) == 1\ntrue\n\njulia> rm.([fname_geno, fname_pheno]);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.plot-Tuple{}","page":"Home","title":"GenomicBreeding.plot","text":"plot(;\n    input::GBInput,\n    skip_genomes::Bool = false,\n    skip_phenomes::Bool = false,\n    skip_cvs::Bool = false,\n    format::String = \"svg\",\n    plot_size::Tuple{Int64,Int64} = (600, 450),\n    overwrite::Bool = false\n)::String\n\nGenerate and save visualization plots for genomic, phenomic, and cross-validation data.\n\nArguments\n\ninput::GBInput: Input configuration containing file paths and settings\nskip_genomes::Bool: If true, skip generating genome-related plots\nskip_phenomes::Bool: If true, skip generating phenome-related plots\nskip_cvs::Bool: If true, skip generating cross-validation plots\nformat::String: Output file format for plots (e.g., \"svg\", \"png\")\nplot_size::Tuple{Int64,Int64}: Dimensions of output plots in pixels (width, height)\noverwrite::Bool: If true, overwrite existing plot files\n\nReturns\n\nString: Path to the output directory containing generated plots\n\nPlot Types\n\nGenomes and Phenomes\n\nDistribution plots\nViolin plots\nCorrelation heatmaps\nTree plots\nPCA biplots\n\nCross-validation\n\nBar plots\nBox plots\n\nOutput Structure\n\nCreates a directory structure under input.fname_out_prefix/plots/ with subdirectories:\n\ngenomes/: Genome-related visualizations\nphenomes/: Phenome-related visualizations\ncvs/: Cross-validation visualizations\n\nExample\n\njulia> genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fname_geno = try writedelimited(genomes, fname=\"test-geno.tsv\"); catch; rm(\"test-geno.tsv\"); writedelimited(genomes, fname=\"test-geno.tsv\"); end;\n\njulia> fname_pheno = try writedelimited(phenomes, fname=\"test-pheno.tsv\"); catch; rm(\"test-pheno.tsv\"); writedelimited(phenomes, fname=\"test-pheno.tsv\"); end;\n    \njulia> input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, SLURM_cpus_per_task=6, SLURM_mem_G=5, fname_out_prefix=\"GBOutput/test-\", verbose=false);\n\njulia> GenomicBreeding.plot(input=input, format=\"png\", plot_size = (700, 525))\n\"GBOutput/plots\"\n\njulia> GenomicBreeding.plot(input=input, format=\"png\", plot_size = (700, 525), overwrite=true, skip_genomes=true)\n\"GBOutput/plots\"\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.predict-Tuple{GBInput}","page":"Home","title":"GenomicBreeding.predict","text":"predict(input::GBInput)::String\n\nPredict trait values (GEBVs) for a set of genotypes using pre-trained models from GenomicBreeding.fit().\n\nArguments\n\ninput::GBInput: Input configuration containing:\nfname_geno: Path to genotype data file\nfname_allele_effects_jld2s: Vector of paths to saved model files from previous fit() calls\nfname_out_prefix: Prefix for output files\nanalysis: Set to GenomicBreeding.predict\n\nReturns\n\nString: Path to the JLD2 file containing predicted phenotypes\n\nDetails\n\nTakes a GBInput object with genotype data and pre-trained models to predict trait values  for new individuals. The function:\n\nLoads genotype data and model parameters\nPredicts trait values using the loaded models\nSaves predictions in a Phenomes struct\nReturns the path to the saved predictions file\n\nOutput File Format\n\nFor single trait prediction: {prefix}{model_name}-predicted_phenomes.jld2\nFor multi-trait prediction: {prefix}{hash}-predicted_phenomes.jld2\n\nExample\n\njulia> genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> proportion_of_variance = fill(0.0, 9, 3); proportion_of_variance[1, :] .= 1.00; # 100% variance on the additive genetic effects\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, proportion_of_variance=proportion_of_variance, verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fname_geno = try writedelimited(genomes, fname=\"test-geno.tsv\"); catch; rm(\"test-geno.tsv\"); writedelimited(genomes, fname=\"test-geno.tsv\"); end;\n\njulia> fname_pheno = try writedelimited(phenomes, fname=\"test-pheno.tsv\"); catch; rm(\"test-pheno.tsv\"); writedelimited(phenomes, fname=\"test-pheno.tsv\"); end;\n\njulia> input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, fname_out_prefix=\"GBOutput_predict_5/output-5-\", analysis=GenomicBreeding.fit, verbose=false);\n\njulia> input.fname_allele_effects_jld2s = GenomicBreeding.fit(input);\n\njulia> input.analysis = GenomicBreeding.predict;\n\njulia> fname_phenomes_predicted = GenomicBreeding.predict(input);\n\njulia> phenomes_predicted = readjld2(Phenomes, fname=fname_phenomes_predicted);\n\njulia> dimensions(phenomes_predicted)\nDict{String, Int64} with 8 entries:\n  \"n_total\"       => 5400\n  \"n_zeroes\"      => 0\n  \"n_nan\"         => 0\n  \"n_entries\"     => 300\n  \"n_traits\"      => 18\n  \"n_inf\"         => 0\n  \"n_populations\" => 3\n  \"n_missing\"     => 0\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.prepareinputs-Tuple{GBInput}","page":"Home","title":"GenomicBreeding.prepareinputs","text":"prepareinputs(input::GBInput)::Vector{GBInput}\n\nCreate a vector of GBInput objects for parallel processing based on the input configuration.\n\nArguments\n\ninput::GBInput: Initial input configuration containing analysis parameters.\n\nReturns\n\nVector{GBInput}: Array of GBInput objects configured for different combinations of:\nModels (RR-BLUP, BayesB, etc.)\nTraits from phenotype data\nPopulation groups (including bulk and across-population analyses)\n\nDetails\n\nFor different analysis types, the function generates the following combinations:\n\nCross-validation (cv): 2 models × traits × (populations + bulk + across-pop)\nModel fitting (fit): 2 models × traits × (populations + bulk)\nPrediction (predict): 1 GBInput per allele effects file\nGWAS (gwas): 1 model × traits × (populations + bulk)\n\nThe function handles special cases:\n\nSkips trait-population combinations with insufficient data\nAdjusts settings for bulk and across-population analyses\nConfigures specific parameters for prediction tasks\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fname_geno = try writedelimited(genomes, fname=\"test-geno.tsv\"); catch; rm(\"test-geno.tsv\"); writedelimited(genomes, fname=\"test-geno.tsv\"); end;\n    \njulia> fname_pheno = try writedelimited(phenomes, fname=\"test-pheno.tsv\"); catch; rm(\"test-pheno.tsv\"); writedelimited(phenomes, fname=\"test-pheno.tsv\"); end;\n\njulia> input_cv = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=GenomicBreeding.cv, verbose=false);\n\njulia> input_fit = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=GenomicBreeding.fit, verbose=false);\n\njulia> input_predict = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, fname_allele_effects_jld2s=[\"dummy.jld2\"], analysis=GenomicBreeding.predict, verbose=false); writejld2(Fit(n=1, l=1), fname=\"dummy.jld2\");\n\njulia> input_gwas = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=GenomicBreeding.gwas, verbose=false);\n\njulia> inputs_cv = prepareinputs(input_cv); # expect 30 GBInputs = 2 models x 3 traits x (3 populations + 1 bulk + 1 across pops)\n\njulia> inputs_fit = prepareinputs(input_fit); # expect 24 GBInputs = 2 models x 3 traits x (3 populations + 1 bulk)\n\njulia> inputs_predict = prepareinputs(input_predict); # expect 1 GBInput = 1 dummy Fit struct\n\njulia> inputs_gwas = prepareinputs(input_gwas); # expect 24 GBInputs = 1 models x 3 traits x (3 populations + 1 bulk)\n\njulia> length(inputs_cv) == 30\ntrue\n\njulia> length(inputs_fit) == 24\ntrue\n\njulia> length(inputs_predict) == 1\ntrue\n\njulia> length(inputs_gwas) == 24\ntrue\n\njulia> rm.([fname_geno, fname_pheno, \"dummy.jld2\"]);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.prepareoutprefixandoutdir-Tuple{GBInput}","page":"Home","title":"GenomicBreeding.prepareoutprefixandoutdir","text":"prepareoutprefixandoutdir(input::GBInput)::String\n\nPrepare the output directory and sanitize the output filename prefix for genomic breeding analysis results.\n\nThis function performs two main tasks:\n\nCreates the output directory if it doesn't exist\nSanitizes the output filename prefix by replacing problematic characters with underscores\n\nArguments\n\ninput::GBInput: Input configuration containing the output file prefix and analysis type\n\nReturns\n\nString: Sanitized output file prefix path\n\nDetails\n\nProblematic characters that are replaced include spaces, newlines, tabs, parentheses,  and special characters (&|:=+*%@!). The function also ensures the prefix ends with  the analysis type and a hyphen.\n\nThrows\n\nArgumentError: If unable to create the output directory\n\nExample\n\njulia> input = GBInput(fname_geno=\"some_dir/fname_geno.jld2\", fname_pheno=\"some_dir/fname_pheno.jld2\", fname_out_prefix=\"GBOutput/some@!_%&prefix\", verbose=false);\n\njulia> fname_out_prefix = prepareoutprefixandoutdir(input)\n\"GBOutput/some_____prefix-cv-\"\n\njulia> rm(dirname(fname_out_prefix), recursive=true);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreeding.submitslurmarrayjobs-Tuple{GBInput}","page":"Home","title":"GenomicBreeding.submitslurmarrayjobs","text":"submitslurmarrayjobs(; input::GBInput)::String\n\nSubmit an array of Slurm jobs for genomic prediction analysis.\n\nArguments\n\ninput::GBInput: A GBInput struct containing all necessary parameters for job submission and analysis.\n\nReturns\n\nString: Path to the output directory where results will be stored.\n\nDetails\n\nThis function handles the submission of parallel genomic prediction jobs to a Slurm cluster. It performs the following steps:\n\nValidates input parameters and checks for required R packages\nCreates necessary output directories\nPrepares individual job inputs\nGenerates Julia and Slurm scripts\nSubmits the array job to the Slurm scheduler\n\nThe function supports various genomic analyses including:\n\nCross-validation (cv)\nModel fitting (fit)\nPrediction (predict)\nGWAS analysis (gwas)\n\nJob Configuration\n\nUses Slurm array jobs for parallel execution\nConfigurable CPU, memory, and time limit parameters\nSupports both module-based and conda environments\nInteractive confirmation before job submission\n\nNotes\n\nRequires a working Slurm environment\nBGLR R package must be installed\nUser will be prompted to enter \"YES\" to confirm job submission\nJob array size is controlled by SLURM_max_array_jobs_running\n\nExample\n\nusing GenomicBreeding, StatsBase;\nusing GenomicBreeding: cv, fit, predict, gwas, ols, rigde, lasso, bayesa, bayesb, bayesc, gwasols, gwaslmm, gwasreml;\ngenomes = GenomicBreeding.GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\ntrials, _ = GenomicBreeding.GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\nphenomes = extractphenomes(trials);\nfname_geno = try writedelimited(genomes, fname=\"test-geno.tsv\"); catch; rm(\"test-geno.tsv\"); writedelimited(genomes, fname=\"test-geno.tsv\"); end;\nfname_pheno = try writedelimited(phenomes, fname=\"test-pheno.tsv\"); catch; rm(\"test-pheno.tsv\"); writedelimited(phenomes, fname=\"test-pheno.tsv\"); end;\n\n# Repeated k-fold cross-validation\ninput_cv = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=cv, SLURM_account_name=\"dbiof1\", SLURM_cpus_per_task=5, SLURM_mem_G=5, fname_out_prefix=\"GBOutput/test-\", verbose=false);\noutdir = submitslurmarrayjobs(input_cv); ### You will be asked to enter \"YES\" to proceed with job submission.\nrun(`sh -c 'squeue -u \"$USER\"'`)\nrun(`sh -c 'tail slurm-*_*.out'`)\nrun(`sh -c 'grep -i \"err\" slurm-*_*.out'`)\ncvs = loadcvs(input_cv)\ndf_across_entries, df_per_entry = tabularise(cvs)\nsum(df_across_entries.model .== \"bayesa\") / nrow(df_across_entries)\nsum(df_across_entries.model .== \"ridge\") / nrow(df_across_entries)\nsort(combine(groupby(df_across_entries, [:validation_population, :model]), [:cor => mean, :cor => length]), :cor_mean, rev=true)\n\n# Genomic prediction equation full data fit\ninput_fit = clone(input_cv)\ninput_fit.analysis = fit\noutdir = submitslurmarrayjobs(input_fit);\ninput_fit.fname_allele_effects_jld2s = begin\n    files = readdir(outdir)\n    idx = findall(.!isnothing.(match.(Regex(\"-fit-\"), files)) .&& .!isnothing.(match.(Regex(\"jld2$\"), files)))\n    joinpath.(outdir, files[idx])\nend\nfits = loadfits(input_fit)\nlength(fits)\n\ninput_predict = clone(input_fit)\ninput_predict.analysis = predict\noutdir = submitslurmarrayjobs(input_predict)\nrun(`squeue`)\n\n\n\n\n\n","category":"method"},{"location":"simulations/","page":"Simulation","title":"Simulation","text":"CurrentModule = GenomicBreeding","category":"page"},{"location":"simulations/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"simulations/","page":"Simulation","title":"Simulation","text":"Simulations","category":"page"},{"location":"simulations/","page":"Simulation","title":"Simulation","text":"","category":"page"},{"location":"simulations/#Simulate-genomes","page":"Simulation","title":"Simulate genomes","text":"","category":"section"},{"location":"simulations/#Simulate-effects","page":"Simulation","title":"Simulate effects","text":"","category":"section"},{"location":"simulations/#Simulate-trials","page":"Simulation","title":"Simulate trials","text":"","category":"section"}]
}
