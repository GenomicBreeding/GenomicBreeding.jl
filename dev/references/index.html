<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · GenomicBreeding.jl</title><meta name="title" content="Reference · GenomicBreeding.jl"/><meta property="og:title" content="Reference · GenomicBreeding.jl"/><meta property="twitter:title" content="Reference · GenomicBreeding.jl"/><meta name="description" content="Documentation for GenomicBreeding.jl."/><meta property="og:description" content="Documentation for GenomicBreeding.jl."/><meta property="twitter:description" content="Documentation for GenomicBreeding.jl."/><meta property="og:url" content="https://GenomicBreeding.github.io/GenomicBreeding.jl/references/"/><meta property="twitter:url" content="https://GenomicBreeding.github.io/GenomicBreeding.jl/references/"/><link rel="canonical" href="https://GenomicBreeding.github.io/GenomicBreeding.jl/references/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GenomicBreeding.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GenomicBreeding.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/main/docs/src/references.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Methods-reference"><a class="docs-heading-anchor" href="#Methods-reference">Methods reference</a><a id="Methods-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-reference" title="Permalink"></a></h1><ul><li><a href="#GenomicBreeding.GBInput"><code>GenomicBreeding.GBInput</code></a></li><li><a href="#Base.:==-Tuple{GBInput, GBInput}"><code>Base.:==</code></a></li><li><a href="#Base.hash-Tuple{GBInput, UInt64}"><code>Base.hash</code></a></li><li><a href="#GBCore.checkdims-Tuple{GBInput}"><code>GBCore.checkdims</code></a></li><li><a href="#GBCore.clone-Tuple{GBInput}"><code>GBCore.clone</code></a></li><li><a href="#GenomicBreeding.checkinputs-Tuple{GBInput}"><code>GenomicBreeding.checkinputs</code></a></li><li><a href="#GenomicBreeding.cv-Tuple{GBInput}"><code>GenomicBreeding.cv</code></a></li><li><a href="#GenomicBreeding.fit-Tuple{GBInput}"><code>GenomicBreeding.fit</code></a></li><li><a href="#GenomicBreeding.gwas-Tuple{GBInput}"><code>GenomicBreeding.gwas</code></a></li><li><a href="#GenomicBreeding.loadcvs-Tuple{GBInput}"><code>GenomicBreeding.loadcvs</code></a></li><li><a href="#GenomicBreeding.loadfits-Tuple{GBInput}"><code>GenomicBreeding.loadfits</code></a></li><li><a href="#GenomicBreeding.loadgenomesphenomes-Tuple{GBInput}"><code>GenomicBreeding.loadgenomesphenomes</code></a></li><li><a href="#GenomicBreeding.plot-Tuple{}"><code>GenomicBreeding.plot</code></a></li><li><a href="#GenomicBreeding.predict-Tuple{GBInput}"><code>GenomicBreeding.predict</code></a></li><li><a href="#GenomicBreeding.prepareinputs-Tuple{GBInput}"><code>GenomicBreeding.prepareinputs</code></a></li><li><a href="#GenomicBreeding.prepareoutprefixandoutdir-Tuple{GBInput}"><code>GenomicBreeding.prepareoutprefixandoutdir</code></a></li><li><a href="#GenomicBreeding.submitslurmarrayjobs-Tuple{GBInput}"><code>GenomicBreeding.submitslurmarrayjobs</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreeding.GBInput" href="#GenomicBreeding.GBInput"><code>GenomicBreeding.GBInput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct GBInput</code></pre><p>Main input struct for genomic breeding analysis (implements GBCore.AbstractGB)</p><p><strong>Fields</strong></p><p><strong>Required</strong></p><ul><li><code>fname_geno</code>: Path to genotype file (see file format guide for details)</li></ul><p><strong>Optional Data Files</strong></p><ul><li><code>fname_pheno</code>: Path to phenotype file (Default: &quot;&quot; - see file format guide for details)</li><li><code>fname_allele_effects_jld2s</code>: Vector of paths to JLD2 files containing Fit structs (Default: [&quot;&quot;])</li></ul><p><strong>Analysis Settings</strong></p><ul><li><code>analysis</code>: Analysis function to perform (Default: cv)<ul><li><code>cv</code>: Replicated k-fold cross-validation</li><li><code>fit</code>: Fit genomic prediction models to extract allele effects</li><li><code>predict</code>: Compute GEBVs using existing model fits</li><li><code>gwas</code>: Genome-wide association study</li></ul></li><li><code>bulk_cv</code>: Perform cross-validation across all populations (Default: false)</li><li><code>populations</code>: Vector of populations to include (Default: all)</li><li><code>traits</code>: Vector of traits to analyze (Default: all)</li><li><code>models</code>: Vector of genomic prediction model functions (Default: [ridge, bayesa])</li><li><code>gwas_models</code>: Vector of GWAS model functions (Default: [gwasols, gwaslmm])</li></ul><p><strong>Cross-Validation Parameters</strong></p><ul><li><code>n_folds</code>: Number of CV folds (Default: 5)</li><li><code>n_replications</code>: Number of CV replications (Default: 5)</li></ul><p><strong>Filtering Parameters</strong></p><ul><li><code>keep_all</code>: Keep all entries when merging data (Default: false)</li><li><code>maf</code>: Minimum allele frequency (Default: 0.05)</li><li><code>mtv</code>: Minimum trait variance (Default: 1e-7)</li></ul><p><strong>Model Parameters</strong></p><ul><li><code>n_iter</code>: MCMC iterations (Default: 1_500)</li><li><code>n_burnin</code>: MCMC burn-in iterations (Default: 500)</li></ul><p><strong>Output Settings</strong></p><ul><li><code>fname_out_prefix</code>: Output file prefix &amp; directory (Default: GBOutput/output-&lt;timestamp&gt;-)</li><li><code>verbose</code>: Show progress messages (Default: true)</li></ul><p><strong>SLURM Settings</strong></p><ul><li><code>SLURM_job_name</code>: Job array name (Default: GBJob-&lt;timestamp&gt;)</li><li><code>SLURM_account_name</code>: Account name (Default: &quot;&quot;)</li><li><code>SLURM_partition_name</code>: Partition to use (Default: &quot;&quot;)</li><li><code>SLURM_nodes_per_array_job</code>: Nodes per job (Default: 1)</li><li><code>SLURM_tasks_per_node</code>: Tasks per node (Default: 1)</li><li><code>SLURM_cpus_per_task</code>: CPUs per task (Default: 1)</li><li><code>SLURM_mem_G</code>: Memory in GB (Default: 1)</li><li><code>SLURM_time_limit_dd_hhmmss</code>: Time limit as &quot;dd-hh:mm:ss&quot; (Default: &quot;00-01:00:00&quot;)</li><li><code>SLURM_max_array_jobs_running</code>: Max concurrent array jobs (Default: 20)</li><li><code>SLURM_module_load_Conda_version_name</code>: Conda module name (Default: &quot;Miniconda3&quot;)</li><li><code>SLURM_module_load_R_version_name</code>: R module name (Default: &quot;conda&quot; which will use the R installed in the conda environment - see installation instructions for details)</li><li><code>SLURM_module_load_Julia_version_name</code>: Julia module name (Default: &quot;&quot; which will use the Julia installed via JuliaUp - see installation instructions for details)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/io.jl#L1-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{GBInput, GBInput}" href="#Base.:==-Tuple{GBInput, GBInput}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.:(==)(x::GBInput, y::GBInput)::Bool</code></pre><p>Compare two <code>GBInput</code> structs for equality by comparing their hash values.</p><p>This method overloads the <code>==</code> operator for <code>GBInput</code> structs, allowing direct comparison using the <code>==</code> operator. Two <code>GBInput</code> structs are considered equal if they have identical hash values, which implies they have the same values for all relevant fields.</p><p><strong>Arguments</strong></p><ul><li><code>x::GBInput</code>: First GBInput struct to compare</li><li><code>y::GBInput</code>: Second GBInput struct to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the hash values of both structs are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; input_1 = input = GBInput(fname_geno=&quot;geno1.jld2&quot;, fname_pheno=&quot;pheno1.jld2&quot;, fname_out_prefix=&quot;test1-&quot;, SLURM_job_name=&quot;slurmjob1&quot;);

julia&gt; input_2 = input = GBInput(fname_geno=&quot;geno1.jld2&quot;, fname_pheno=&quot;pheno1.jld2&quot;, fname_out_prefix=&quot;test1-&quot;, SLURM_job_name=&quot;slurmjob1&quot;);

julia&gt; input_3 = input = GBInput(fname_geno=&quot;geno2.jld2&quot;, fname_pheno=&quot;pheno2.jld2&quot;);

julia&gt; input_1 == input_2
true

julia&gt; input_1 == input_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/io.jl#L202-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hash-Tuple{GBInput, UInt64}" href="#Base.hash-Tuple{GBInput, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.hash(x::GBInput, h::UInt)::UInt</code></pre><p>Compute a hash value for a <code>GBInput</code> struct by combining the hash values of all its fields.</p><p><strong>Arguments</strong></p><ul><li><code>x::GBInput</code>: The input structure to be hashed</li><li><code>h::UInt</code>: The hash value seed</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: A hash value that uniquely identifies the content of the <code>GBInput</code> struct</li></ul><p><strong>Details</strong></p><p>This method implements hash computation for the <code>GBInput</code> type by iterating through all fields and combining their hash values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; input = GBInput(fname_geno=&quot;&quot;, fname_pheno=&quot;&quot;);

julia&gt; typeof(hash(input))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/io.jl#L168-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.checkdims-Tuple{GBInput}" href="#GBCore.checkdims-Tuple{GBInput}"><code>GBCore.checkdims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkdims(input::GBInput)::Bool</code></pre><p>Check dimension compatibility of the fields of the GBInput struct. Returns <code>true</code> if both <code>models</code> and <code>gwas_models</code> fields in the input are not <code>nothing</code>, <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>input::GBInput</code>: Input structure containing genomic data and models</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if dimensions are compatible, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; input = GBInput(fname_geno=&quot;geno1.jld2&quot;, fname_pheno=&quot;pheno1.jld2&quot;);

julia&gt; checkdims(input)
true

julia&gt; input.models = nothing

julia&gt; checkdims(input)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/io.jl#L271-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBCore.clone-Tuple{GBInput}" href="#GBCore.clone-Tuple{GBInput}"><code>GBCore.clone</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clone(x::GBInput)::GBInput</code></pre><p>Create a deep copy of a GBInput object, duplicating all field values into a new instance.</p><p>This function allows you to create an independent copy of a GBInput object where modifications  to the clone won&#39;t affect the original object.</p><p><strong>Arguments</strong></p><ul><li><code>x::GBInput</code>: The source GBInput object to be cloned</li></ul><p><strong>Returns</strong></p><ul><li><code>::GBInput</code>: A new GBInput instance with identical field values</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; input = GBInput(fname_geno=&quot;geno1.jld2&quot;, fname_pheno=&quot;pheno1.jld2&quot;);

julia&gt; copy_input = clone(input);

julia&gt; input == copy_input
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/io.jl#L237-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreeding.checkinputs-Tuple{GBInput}" href="#GenomicBreeding.checkinputs-Tuple{GBInput}"><code>GenomicBreeding.checkinputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkinputs(input::GBInput)::Vector{String}</code></pre><p>Check the compatibility and validity of inputs for genomic analysis.</p><p>Returns a vector of error messages. An empty vector indicates all inputs are valid.</p><p><strong>Arguments</strong></p><ul><li><code>input::GBInput</code>: A struct containing analysis parameters including:<ul><li><code>analysis</code>: Analysis type (<code>cv</code>, <code>fit</code>, <code>predict</code>, or <code>gwas</code>)</li><li><code>fname_geno</code>: Path to genotype file</li><li><code>fname_pheno</code>: Path to phenotype file</li><li><code>models</code>: Vector of selected models</li><li><code>fname_allele_effects_jld2s</code>: Paths to allele effects files (for predict)</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: Collection of error messages, empty if all inputs are valid</li></ul><p><strong>Validation Rules</strong></p><ul><li>Analysis type must be one of: <code>cv</code>, <code>fit</code>, <code>predict</code>, or <code>gwas</code></li><li>For <code>cv</code>, <code>fit</code>, and <code>gwas</code>:<ul><li>Genotype file must exist</li><li>Phenotype file must exist</li><li>At least one model must be specified</li></ul></li><li>For <code>predict</code>:<ul><li>Genotype file must exist</li><li>All specified allele effects files must exist</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fname_geno = try writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); catch; rm(&quot;test-geno.tsv&quot;); writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); end;
    
julia&gt; fname_pheno = try writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); catch; rm(&quot;test-pheno.tsv&quot;); writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); end;

julia&gt; input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=cv);

julia&gt; length(checkinputs(input)) == 0
true

julia&gt; input.fname_pheno = &quot;&quot;; length(checkinputs(input)) == 0
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/io.jl#L301-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreeding.cv-Tuple{GBInput}" href="#GenomicBreeding.cv-Tuple{GBInput}"><code>GenomicBreeding.cv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cv(input::GBInput)::Tuple{Vector{String},Vector{String}}</code></pre><p>Assess genomic prediction accuracy via replicated k-fold cross-validation.</p><p><strong>Arguments</strong></p><ul><li><code>input::GBInput</code>: A GBInput struct containing configuration parameters including:<ul><li><code>bulk_cv</code>: Boolean flag for bulk cross-validation</li><li><code>populations</code>: Vector of population names to analyze</li><li><code>models</code>: Statistical models to use for prediction</li><li><code>n_folds</code>: Number of folds for cross-validation</li><li><code>n_replications</code>: Number of replications for cross-validation</li><li><code>fname_out_prefix</code>: Prefix for output filenames</li><li><code>verbose</code>: Boolean flag for detailed output</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{String},Vector{String}}</code>: A tuple containing:<ul><li>First element: Vector of paths to JLD2 files containing CV results</li><li>Second element: Vector of paths to text files containing error notes</li></ul></li></ul><p><strong>Details</strong></p><p>The function supports three types of cross-validation:</p><ul><li>Single population CV when one population is specified</li><li>Pairwise population CV when two populations are specified</li><li>Both pairwise and leave-one-population-out CV when more than two populations are specified</li></ul><p>Results are saved as JLD2 files (one per fold, replication, and trait) and optional text files  containing notes about failed jobs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; proportion_of_variance = fill(0.0, 9, 3); proportion_of_variance[1, :] .= 1.00; # 100% variance on the additive genetic effects

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, proportion_of_variance=proportion_of_variance, verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fname_geno = try writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); catch; rm(&quot;test-geno.tsv&quot;); writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); end;

julia&gt; fname_pheno = try writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); catch; rm(&quot;test-pheno.tsv&quot;); writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); end;

julia&gt; input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=cv, bulk_cv=false, fname_out_prefix=&quot;GBOutput_cv_3/output-3-&quot;, populations=[&quot;pop_1&quot;, &quot;pop_3&quot;], traits=[&quot;trait_1&quot;], n_replications=2, n_folds=3, verbose=false);

julia&gt; fnames_cvs, fnames_notes = cv(input);

julia&gt; length(fnames_cvs) == 4, length(fnames_notes) == 0
(true, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/genomic_prediction.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreeding.fit-Tuple{GBInput}" href="#GenomicBreeding.fit-Tuple{GBInput}"><code>GenomicBreeding.fit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit(input::GBInput)::Vector{String}</code></pre><p>Extract allele effects by fitting genomic prediction models without cross-validation.</p><p><strong>Arguments</strong></p><ul><li><code>input::GBInput</code>: A GBInput struct containing:<ul><li><code>fname_geno</code>: Path to genotype data file</li><li><code>fname_pheno</code>: Path to phenotype data file</li><li><code>models</code>: Vector of model functions to fit (e.g., [bayesa, bayesb])</li><li><code>traits</code>: Optional vector of trait names to analyze</li><li><code>populations</code>: Optional vector of population names to analyze</li><li><code>n_iter</code>: Number of iterations for Bayesian models</li><li><code>n_burnin</code>: Number of burn-in iterations for Bayesian models</li><li><code>verbose</code>: Boolean for detailed output</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: Paths to JLD2 files containing fitted model results, one file per model-trait-population combination</li></ul><p><strong>Details</strong></p><p>The function fits specified genomic prediction models to the full dataset without cross-validation.  For each combination of model, trait, and population, it:</p><ol><li>Loads and processes genotype and phenotype data</li><li>Fits the specified model</li><li>Saves results to a JLD2 file with naming pattern: <code>{prefix}_model_{name}-trait_{name}-population_{name}.jld2</code></li></ol><p><strong>Notes</strong></p><ul><li>If populations is not specified, all unique populations in phenotype data are used</li><li>If traits is not specified, all unique traits in phenotype data are used</li><li>For Bayesian models (names containing &quot;bayes&quot;), uses specified iterations and burn-in</li><li>Will throw an error if output files already exist</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; proportion_of_variance = fill(0.0, 9, 3); proportion_of_variance[1, :] .= 1.00; # 100% variance on the additive genetic effects

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, proportion_of_variance=proportion_of_variance, verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fname_geno = try writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); catch; rm(&quot;test-geno.tsv&quot;); writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); end;

julia&gt; fname_pheno = try writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); catch; rm(&quot;test-pheno.tsv&quot;); writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); end;

julia&gt; input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=GenomicBreeding.fit, fname_out_prefix=&quot;GBOutput_fit_4/output-4-&quot;, populations=[&quot;pop_1&quot;, &quot;pop_3&quot;], traits=[&quot;trait_1&quot;], models=[bayesa, bayesb], verbose=false);

julia&gt; fname_allele_effects_jld2s = GenomicBreeding.fit(input);

julia&gt; length(fname_allele_effects_jld2s) == 4
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/genomic_prediction.jl#L119-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreeding.gwas-Tuple{GBInput}" href="#GenomicBreeding.gwas-Tuple{GBInput}"><code>GenomicBreeding.gwas</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gwas(input::GBInput)::Vector{String}</code></pre><p>Perform genome-wide association study (GWAS) analysis on genomic and phenotypic data.</p><p><strong>Arguments</strong></p><ul><li><code>input::GBInput</code>: A GBInput struct containing:<ul><li><code>fname_geno</code>: Path to genotype data file</li><li><code>fname_pheno</code>: Path to phenotype data file</li><li><code>gwas_models</code>: Vector of GWAS models to apply</li><li><code>traits</code>: Optional vector of trait names to analyze</li><li><code>populations</code>: Optional vector of population names to analyze</li><li><code>verbose</code>: Boolean flag for detailed output</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: Paths to generated JLD2 files containing Fit structs for each model-trait-population combination</li></ul><p><strong>Details</strong></p><p>The function performs GWAS analysis for each combination of:</p><ul><li>GWAS models specified in input</li><li>Traits found in phenotype data</li><li>Populations specified (if none specified, analyzes all data together)</li></ul><p>For each combination, it:</p><ol><li>Filters data for the specific population if specified</li><li>Fits the GWAS model</li><li>Saves results to a JLD2 file containing a Fit struct</li></ol><p>The Fit struct&#39;s <code>b_hat</code> field contains:</p><ul><li>t-statistics for <code>gwasols</code> model</li><li>z-statistics for other GWAS models</li></ul><p><strong>Notes</strong></p><ul><li>Output files are named as: <code>&lt;prefix&gt;_model_&lt;model&gt;-trait_&lt;trait&gt;-population_&lt;pop&gt;.jld2</code></li><li>Will throw an error if output files already exist</li><li>When verbose=true, displays a progress bar and correlation heatmap of estimated allele effects</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; proportion_of_variance = fill(0.0, 9, 3); proportion_of_variance[1, :] .= 1.00; # 100% variance on the additive genetic effects

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, proportion_of_variance=proportion_of_variance, verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fname_geno = try writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); catch; rm(&quot;test-geno.tsv&quot;); writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); end;

julia&gt; fname_pheno = try writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); catch; rm(&quot;test-pheno.tsv&quot;); writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); end;

julia&gt; input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, gwas_models=[gwasols], verbose=false);

julia&gt; fname_test_statistics_jld2s = GenomicBreeding.gwas(input);

julia&gt; length(fname_test_statistics_jld2s) == 3
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/gwas.jl#L1-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreeding.loadcvs-Tuple{GBInput}" href="#GenomicBreeding.loadcvs-Tuple{GBInput}"><code>GenomicBreeding.loadcvs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loadcvs(input::GBInput; min_train_size::Int64=10)::Vector{CV}</code></pre><p>Load and filter cross-validation (CV) results from files generated by <code>GenomicBreeding.cv()</code>.</p><p><strong>Arguments</strong></p><ul><li><code>input::GBInput</code>: Input configuration containing the output directory path in <code>fname_out_prefix</code></li><li><code>min_train_size::Int64=10</code>: Minimum required size for training sets (default: 10)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{CV}</code>: Vector of valid CV objects that meet the following criteria:<ul><li>Contains complete metrics (length of fit.metrics == 9)</li><li>Has valid correlation metric (not missing, NaN, or Inf)</li><li>Validation set size ≥ min<em>train</em>size</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the output directory doesn&#39;t exist or contains no CV results</li></ul><p><strong>Details</strong></p><p>The function searches for files with pattern &quot;-cv-&quot; and extension &quot;.jld2&quot; in the output directory. Invalid or failed CV results are automatically filtered out during loading.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; proportion_of_variance = fill(0.0, 9, 3); proportion_of_variance[1, :] .= 1.00; # 100% variance on the additive genetic effects

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, proportion_of_variance=proportion_of_variance, verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fname_geno = try writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); catch; rm(&quot;test-geno.tsv&quot;); writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); end;

julia&gt; fname_pheno = try writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); catch; rm(&quot;test-pheno.tsv&quot;); writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); end;

julia&gt; input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, fname_out_prefix=&quot;GBOutput_cv_1/output-1-&quot;, populations=[&quot;pop_1&quot;, &quot;pop_3&quot;], traits=[&quot;trait_1&quot;], n_replications=2, n_folds=3, verbose=false);

julia&gt; fnames_cvs, fnames_notes = cv(input);

julia&gt; cvs = loadcvs(input);

julia&gt; length(cvs) == length(fnames_cvs)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/io.jl#L722-L767">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreeding.loadfits-Tuple{GBInput}" href="#GenomicBreeding.loadfits-Tuple{GBInput}"><code>GenomicBreeding.loadfits</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loadfits(input::GBInput)::Vector{Fit}</code></pre><p>Load fitted allele frequency effects from genomic prediction models stored in JLD2 files.</p><p><strong>Arguments</strong></p><ul><li><code>input::GBInput</code>: Input configuration containing paths to JLD2 files with fitted allele effects.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Fit}</code>: Array of <code>Fit</code> objects containing the loaded allele frequency effects.</li></ul><p><strong>Details</strong></p><p>The function attempts to load all JLD2 files specified in <code>input.fname_allele_effects_jld2s</code>. If a file cannot be loaded, that entry will be skipped and remain <code>undef</code> in the output vector.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; proportion_of_variance = fill(0.0, 9, 3); proportion_of_variance[1, :] .= 1.00; # 100% variance on the additive genetic effects

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, proportion_of_variance=proportion_of_variance, verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fname_geno = try writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); catch; rm(&quot;test-geno.tsv&quot;); writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); end;

julia&gt; fname_pheno = try writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); catch; rm(&quot;test-pheno.tsv&quot;); writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); end;

julia&gt; input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, fname_out_prefix=&quot;GBOutput_fit_2/output-2-&quot;, populations=[&quot;pop_1&quot;, &quot;pop_3&quot;], traits=[&quot;trait_1&quot;], models=[bayesa, bayesb], verbose=false);

julia&gt; input.fname_allele_effects_jld2s = GenomicBreeding.fit(input);

julia&gt; fits = loadfits(input);

julia&gt; length(fits) == length(input.fname_allele_effects_jld2s)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/io.jl#L823-L861">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreeding.loadgenomesphenomes-Tuple{GBInput}" href="#GenomicBreeding.loadgenomesphenomes-Tuple{GBInput}"><code>GenomicBreeding.loadgenomesphenomes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loadgenomesphenomes(input::GBInput)::Tuple{Genomes, Phenomes, Vector{String}, Vector{String}}</code></pre><p>Load, merge, and filter genotype and phenotype data from specified input files.</p><p><strong>Arguments</strong></p><ul><li><code>input::GBInput</code>: A struct containing input parameters including:<ul><li><code>fname_geno</code>: Path to genotype data file</li><li><code>fname_pheno</code>: Path to phenotype data file</li><li><code>bulk_cv</code>: Boolean for bulk cross-validation</li><li><code>populations</code>: Vector of population names to include (optional)</li><li><code>traits</code>: Vector of trait names to include (optional)</li><li><code>n_folds</code>: Number of cross-validation folds</li><li><code>keep_all</code>: Boolean to keep all entries during merging</li><li><code>maf</code>: Minimum allele frequency threshold</li><li><code>mtv</code>: Minimum trait variance threshold</li><li><code>verbose</code>: Boolean for detailed output</li></ul></li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ol><li><code>Genomes</code>: Filtered genomic data</li><li><code>Phenomes</code>: Filtered phenotypic data</li><li><code>Vector{String}</code>: Traits to skip due to insufficient data for cross-validation</li><li><code>Vector{String}</code>: Populations to skip due to insufficient data for cross-validation</li></ol><p><strong>Notes</strong></p><ul><li>Supports multiple file formats (string-delimited, JLD2, VCF)</li><li>Performs data validation and compatibility checks</li><li>Filters traits with variance below minimum trait variance (mtv) threshold</li><li>Ensures sufficient sample size for cross-validation</li><li>Filters markers based on minimum allele frequency (maf)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fname_geno = try writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); catch; rm(&quot;test-geno.tsv&quot;); writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); end;
    
julia&gt; fname_pheno = try writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); catch; rm(&quot;test-pheno.tsv&quot;); writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); end;

julia&gt; input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, populations=[&quot;pop_1&quot;, &quot;pop_3&quot;], traits=[&quot;trait_1&quot;], verbose=false);

julia&gt; genomes, phenomes, traits_to_skip, populations_to_skip = loadgenomesphenomes(input);

julia&gt; length(unique(genomes.populations)) == length(unique(phenomes.populations)) == 2
true

julia&gt; length(phenomes.traits) == 1
true

julia&gt; rm.([fname_geno, fname_pheno]);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/io.jl#L410-L466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreeding.plot-Tuple{}" href="#GenomicBreeding.plot-Tuple{}"><code>GenomicBreeding.plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(;
    input::GBInput,
    skip_genomes::Bool = false,
    skip_phenomes::Bool = false,
    skip_cvs::Bool = false,
    format::String = &quot;svg&quot;,
    plot_size::Tuple{Int64,Int64} = (600, 450),
    overwrite::Bool = false
)::String</code></pre><p>Generate and save visualization plots for genomic, phenomic, and cross-validation data.</p><p><strong>Arguments</strong></p><ul><li><code>input::GBInput</code>: Input configuration containing file paths and settings</li><li><code>skip_genomes::Bool</code>: If true, skip generating genome-related plots</li><li><code>skip_phenomes::Bool</code>: If true, skip generating phenome-related plots</li><li><code>skip_cvs::Bool</code>: If true, skip generating cross-validation plots</li><li><code>format::String</code>: Output file format for plots (e.g., &quot;svg&quot;, &quot;png&quot;)</li><li><code>plot_size::Tuple{Int64,Int64}</code>: Dimensions of output plots in pixels (width, height)</li><li><code>overwrite::Bool</code>: If true, overwrite existing plot files</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the output directory containing generated plots</li></ul><p><strong>Plot Types</strong></p><p><strong>Genomes and Phenomes</strong></p><ul><li>Distribution plots</li><li>Violin plots</li><li>Correlation heatmaps</li><li>Tree plots</li><li>PCA biplots</li></ul><p><strong>Cross-validation</strong></p><ul><li>Bar plots</li><li>Box plots</li></ul><p><strong>Output Structure</strong></p><p>Creates a directory structure under <code>input.fname_out_prefix/plots/</code> with subdirectories:</p><ul><li><code>genomes/</code>: Genome-related visualizations</li><li><code>phenomes/</code>: Phenome-related visualizations</li><li><code>cvs/</code>: Cross-validation visualizations</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fname_geno = try writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); catch; rm(&quot;test-geno.tsv&quot;); writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); end;

julia&gt; fname_pheno = try writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); catch; rm(&quot;test-pheno.tsv&quot;); writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); end;
    
julia&gt; input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, SLURM_cpus_per_task=6, SLURM_mem_G=5, fname_out_prefix=&quot;GBOutput/test-&quot;, verbose=false);

julia&gt; GenomicBreeding.plot(input=input, format=&quot;png&quot;, plot_size = (700, 525))
&quot;GBOutput/plots&quot;

julia&gt; GenomicBreeding.plot(input=input, format=&quot;png&quot;, plot_size = (700, 525), overwrite=true, skip_genomes=true)
&quot;GBOutput/plots&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/plot.jl#L1-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreeding.predict-Tuple{GBInput}" href="#GenomicBreeding.predict-Tuple{GBInput}"><code>GenomicBreeding.predict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict(input::GBInput)::String</code></pre><p>Predict trait values (GEBVs) for a set of genotypes using pre-trained models from <code>GenomicBreeding.fit()</code>.</p><p><strong>Arguments</strong></p><ul><li><code>input::GBInput</code>: Input configuration containing:<ul><li><code>fname_geno</code>: Path to genotype data file</li><li><code>fname_allele_effects_jld2s</code>: Vector of paths to saved model files from previous <code>fit()</code> calls</li><li><code>fname_out_prefix</code>: Prefix for output files</li><li><code>analysis</code>: Set to <code>GenomicBreeding.predict</code></li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the JLD2 file containing predicted phenotypes</li></ul><p><strong>Details</strong></p><p>Takes a <code>GBInput</code> object with genotype data and pre-trained models to predict trait values  for new individuals. The function:</p><ol><li>Loads genotype data and model parameters</li><li>Predicts trait values using the loaded models</li><li>Saves predictions in a Phenomes struct</li><li>Returns the path to the saved predictions file</li></ol><p><strong>Output File Format</strong></p><ul><li>For single trait prediction: <code>{prefix}{model_name}-predicted_phenomes.jld2</code></li><li>For multi-trait prediction: <code>{prefix}{hash}-predicted_phenomes.jld2</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; proportion_of_variance = fill(0.0, 9, 3); proportion_of_variance[1, :] .= 1.00; # 100% variance on the additive genetic effects

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, proportion_of_variance=proportion_of_variance, verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fname_geno = try writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); catch; rm(&quot;test-geno.tsv&quot;); writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); end;

julia&gt; fname_pheno = try writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); catch; rm(&quot;test-pheno.tsv&quot;); writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); end;

julia&gt; input = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, fname_out_prefix=&quot;GBOutput_predict_5/output-5-&quot;, analysis=GenomicBreeding.fit, verbose=false);

julia&gt; input.fname_allele_effects_jld2s = GenomicBreeding.fit(input);

julia&gt; input.analysis = GenomicBreeding.predict;

julia&gt; fname_phenomes_predicted = GenomicBreeding.predict(input);

julia&gt; phenomes_predicted = readjld2(Phenomes, fname=fname_phenomes_predicted);

julia&gt; dimensions(phenomes_predicted)
Dict{String, Int64} with 8 entries:
  &quot;n_total&quot;       =&gt; 5400
  &quot;n_zeroes&quot;      =&gt; 0
  &quot;n_nan&quot;         =&gt; 0
  &quot;n_entries&quot;     =&gt; 300
  &quot;n_traits&quot;      =&gt; 18
  &quot;n_inf&quot;         =&gt; 0
  &quot;n_populations&quot; =&gt; 3
  &quot;n_missing&quot;     =&gt; 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/genomic_prediction.jl#L273-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreeding.prepareinputs-Tuple{GBInput}" href="#GenomicBreeding.prepareinputs-Tuple{GBInput}"><code>GenomicBreeding.prepareinputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepareinputs(input::GBInput)::Vector{GBInput}</code></pre><p>Create a vector of <code>GBInput</code> objects for parallel processing based on the input configuration.</p><p><strong>Arguments</strong></p><ul><li><code>input::GBInput</code>: Initial input configuration containing analysis parameters.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{GBInput}</code>: Array of <code>GBInput</code> objects configured for different combinations of:<ul><li>Models (RR-BLUP, BayesB, etc.)</li><li>Traits from phenotype data</li><li>Population groups (including bulk and across-population analyses)</li></ul></li></ul><p><strong>Details</strong></p><p>For different analysis types, the function generates the following combinations:</p><ul><li>Cross-validation (<code>cv</code>): 2 models × traits × (populations + bulk + across-pop)</li><li>Model fitting (<code>fit</code>): 2 models × traits × (populations + bulk)</li><li>Prediction (<code>predict</code>): 1 GBInput per allele effects file</li><li>GWAS (<code>gwas</code>): 1 model × traits × (populations + bulk)</li></ul><p>The function handles special cases:</p><ul><li>Skips trait-population combinations with insufficient data</li><li>Adjusts settings for bulk and across-population analyses</li><li>Configures specific parameters for prediction tasks</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fname_geno = try writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); catch; rm(&quot;test-geno.tsv&quot;); writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); end;
    
julia&gt; fname_pheno = try writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); catch; rm(&quot;test-pheno.tsv&quot;); writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); end;

julia&gt; input_cv = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=GenomicBreeding.cv, verbose=false);

julia&gt; input_fit = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=GenomicBreeding.fit, verbose=false);

julia&gt; input_predict = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, fname_allele_effects_jld2s=[&quot;dummy.jld2&quot;], analysis=GenomicBreeding.predict, verbose=false); writejld2(Fit(n=1, l=1), fname=&quot;dummy.jld2&quot;);

julia&gt; input_gwas = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=GenomicBreeding.gwas, verbose=false);

julia&gt; inputs_cv = prepareinputs(input_cv); # expect 30 GBInputs = 2 models x 3 traits x (3 populations + 1 bulk + 1 across pops)

julia&gt; inputs_fit = prepareinputs(input_fit); # expect 24 GBInputs = 2 models x 3 traits x (3 populations + 1 bulk)

julia&gt; inputs_predict = prepareinputs(input_predict); # expect 1 GBInput = 1 dummy Fit struct

julia&gt; inputs_gwas = prepareinputs(input_gwas); # expect 24 GBInputs = 1 models x 3 traits x (3 populations + 1 bulk)

julia&gt; length(inputs_cv) == 30
true

julia&gt; length(inputs_fit) == 24
true

julia&gt; length(inputs_predict) == 1
true

julia&gt; length(inputs_gwas) == 24
true

julia&gt; rm.([fname_geno, fname_pheno, &quot;dummy.jld2&quot;]);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/io.jl#L875-L943">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreeding.prepareoutprefixandoutdir-Tuple{GBInput}" href="#GenomicBreeding.prepareoutprefixandoutdir-Tuple{GBInput}"><code>GenomicBreeding.prepareoutprefixandoutdir</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepareoutprefixandoutdir(input::GBInput)::String</code></pre><p>Prepare the output directory and sanitize the output filename prefix for genomic breeding analysis results.</p><p>This function performs two main tasks:</p><ol><li>Creates the output directory if it doesn&#39;t exist</li><li>Sanitizes the output filename prefix by replacing problematic characters with underscores</li></ol><p><strong>Arguments</strong></p><ul><li><code>input::GBInput</code>: Input configuration containing the output file prefix and analysis type</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Sanitized output file prefix path</li></ul><p><strong>Details</strong></p><p>Problematic characters that are replaced include spaces, newlines, tabs, parentheses,  and special characters (<code>&amp;|:=+*%@!</code>). The function also ensures the prefix ends with  the analysis type and a hyphen.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If unable to create the output directory</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; input = GBInput(fname_geno=&quot;some_dir/fname_geno.jld2&quot;, fname_pheno=&quot;some_dir/fname_pheno.jld2&quot;, fname_out_prefix=&quot;GBOutput/some@!_%&amp;prefix&quot;, verbose=false);

julia&gt; fname_out_prefix = prepareoutprefixandoutdir(input)
&quot;GBOutput/some_____prefix-cv-&quot;

julia&gt; rm(dirname(fname_out_prefix), recursive=true);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/io.jl#L1028-L1060">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreeding.submitslurmarrayjobs-Tuple{GBInput}" href="#GenomicBreeding.submitslurmarrayjobs-Tuple{GBInput}"><code>GenomicBreeding.submitslurmarrayjobs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">submitslurmarrayjobs(; input::GBInput)::String</code></pre><p>Submit an array of Slurm jobs for genomic prediction analysis.</p><p><strong>Arguments</strong></p><ul><li><code>input::GBInput</code>: A GBInput struct containing all necessary parameters for job submission and analysis.</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the output directory where results will be stored.</li></ul><p><strong>Details</strong></p><p>This function handles the submission of parallel genomic prediction jobs to a Slurm cluster. It performs the following steps:</p><ol><li>Validates input parameters and checks for required R packages</li><li>Creates necessary output directories</li><li>Prepares individual job inputs</li><li>Generates Julia and Slurm scripts</li><li>Submits the array job to the Slurm scheduler</li></ol><p>The function supports various genomic analyses including:</p><ul><li>Cross-validation (cv)</li><li>Model fitting (fit)</li><li>Prediction (predict)</li><li>GWAS analysis (gwas)</li></ul><p><strong>Job Configuration</strong></p><ul><li>Uses Slurm array jobs for parallel execution</li><li>Configurable CPU, memory, and time limit parameters</li><li>Supports both module-based and conda environments</li><li>Interactive confirmation before job submission</li></ul><p><strong>Notes</strong></p><ul><li>Requires a working Slurm environment</li><li>BGLR R package must be installed</li><li>User will be prompted to enter &quot;YES&quot; to confirm job submission</li><li>Job array size is controlled by <code>SLURM_max_array_jobs_running</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using GenomicBreeding, StatsBase;
using GenomicBreeding: cv, fit, predict, gwas, ols, rigde, lasso, bayesa, bayesb, bayesc, gwasols, gwaslmm, gwasreml;
genomes = GenomicBreeding.GBCore.simulategenomes(n=300, l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);
trials, _ = GenomicBreeding.GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);
phenomes = extractphenomes(trials);
fname_geno = try writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); catch; rm(&quot;test-geno.tsv&quot;); writedelimited(genomes, fname=&quot;test-geno.tsv&quot;); end;
fname_pheno = try writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); catch; rm(&quot;test-pheno.tsv&quot;); writedelimited(phenomes, fname=&quot;test-pheno.tsv&quot;); end;

# Repeated k-fold cross-validation
input_cv = GBInput(fname_geno=fname_geno, fname_pheno=fname_pheno, analysis=cv, SLURM_account_name=&quot;dbiof1&quot;, SLURM_cpus_per_task=5, SLURM_mem_G=5, fname_out_prefix=&quot;GBOutput/test-&quot;, verbose=false);
outdir = submitslurmarrayjobs(input_cv); ### You will be asked to enter &quot;YES&quot; to proceed with job submission.
run(`sh -c &#39;squeue -u &quot;$USER&quot;&#39;`)
run(`sh -c &#39;tail slurm-*_*.out&#39;`)
run(`sh -c &#39;grep -i &quot;err&quot; slurm-*_*.out&#39;`)
cvs = loadcvs(input_cv)
df_across_entries, df_per_entry = tabularise(cvs)
sum(df_across_entries.model .== &quot;bayesa&quot;) / nrow(df_across_entries)
sum(df_across_entries.model .== &quot;ridge&quot;) / nrow(df_across_entries)
sort(combine(groupby(df_across_entries, [:validation_population, :model]), [:cor =&gt; mean, :cor =&gt; length]), :cor_mean, rev=true)

# Genomic prediction equation full data fit
input_fit = clone(input_cv)
input_fit.analysis = fit
outdir = submitslurmarrayjobs(input_fit);
input_fit.fname_allele_effects_jld2s = begin
    files = readdir(outdir)
    idx = findall(.!isnothing.(match.(Regex(&quot;-fit-&quot;), files)) .&amp;&amp; .!isnothing.(match.(Regex(&quot;jld2$&quot;), files)))
    joinpath.(outdir, files[idx])
end
fits = loadfits(input_fit)
length(fits)

input_predict = clone(input_fit)
input_predict.analysis = predict
outdir = submitslurmarrayjobs(input_predict)
run(`squeue`)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreeding.jl/blob/b6742f8b69eb4cd452ab7088550e4f2e0e71a68c/src/slurm.jl#L1-L77">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/">« Manual</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Friday 21 March 2025 16:47">Friday 21 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
